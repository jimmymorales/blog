# Type Casting Autom√°tico en Kotlin

Type Casting Autom√°tico en Kotlin

Photo by [Suzanne D. Williams](https://unsplash.com/@scw1217?utm_source=medium&utm_medium=referral) on¬†[Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

> En el primer episodio de [TGIK](https://youtu.be/G-Oyo1fCD_E), vimos una introducci√≥n al mundo de *Kotlin* e incluso logramos explicar caracter√≠sticas b√°sicas de *Kotlin* que hacen que escribirlo sea divertido y f√°cil de leer. ü§ì

> Una de esas caracter√≠sticas fue el type casting autom√°tico, y en esta oportunidad veremos m√°s a detalle como est√° caracter√≠stica es posible.

> Si no han logrado ver este episodio, les comporta el enlace: üëÄ

<iframe src="https://youtu.be/G-Oyo1fCD_E" width="700" height="393" frameborder="0" scrolling="no"></iframe>
TGIK‚Ää‚Äî‚Ääepisodes\[0\] = ‚ÄúKotlin Starter Pack‚Äù

El type casting autom√°tico es una de las muchas caracter√≠sticas que hacen a *Kotlin* un lenguaje sensacional. Si son curiosos como yo, tal vez querr√°n saber como el compilador de *Kotlin* hace que el type casting autom√°tico nos ayude a tener un c√≥digo m√°s conciso.

### Type Casting

*Kotlin* es un lenguaje de programaci√≥n de tipado *est√°tico*, lo que quiere decir que la comprobaci√≥n de tipos se realiza durante la compilaci√≥n, y no durante la ejecuci√≥n.

Pero, ¬øa qu√© me refiero con tipos? Kotlin fue dise√±ado para poder usarse con el paradigma de [programaci√≥n orientada a objetos](https://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos). En este paradigma cada objeto que se define es una instancia de una clase, o en otras palabras, cada objeto tiene un *tipo* de dato asociado.

### El Operador¬†`is`

Tenemos que mencionar al operador que hace el type casting autom√°tico sea posible. Me refiero al operador `is`. Este operador revisa si una expresi√≥n es una instancia de un tipo.

``` kotlin
fun main() {
    val obj: Any = "Kotlin!"
    if (obj is String) {
        println("obj es un String")
    }
}
```

Tambi√©n existe la contraparte¬†`!is` que es equivalente a escribir¬†`!(obj is String)`.

### Type Casting‚Ä¶ Autom√°tico

Lo realmente genial del operador `is` es cuando se revisa una variable local o propiedad que es inmutable. En este caso no hay necesidad de convertirla expl√≠citamente. Creo que queda m√°s claro si lo vemos con c√≥digo:

``` kotlin
fun getStringLength(obj: Any): Int? {
    if (obj is String) {
        // `obj` se convierte automaticamente a `String` en este bloque
        return obj.length
    }

    // `obj` aun es de tipo `Any` afuera del cuerpo del `if`
    return null
}
```

Y eso no es todo. El inteligente compilador de Kotlin sabe convertir autom√°ticamente entre datos cuando se usan los operadores `&&` o `||` en condiciones. Tambi√©n funciona en expresiones `when` y ciclos `while`. Veamos lo en c√≥digo:

``` kotlin
fun main() {
    val obj: Any = "TGIK!"
    
    // obj es convertido automaticamente a String en el lado derecho de `||`
    if (obj !is String || obj.length == 0) return

    // obj es convertido automaticamente a String en el lado derecho de `&&`
    if (obj is String && obj.length > 0) {
        println(obj.length) // obj es convertido automaticamente a String
    }
    
    when (obj) {
    	is Int -> print(obj + 1)
    	is String -> print(obj.length + 1)
    	is IntArray -> print(obj.sum())
    }
}
```

### Type casting autom√°tico tras bambalinas

En est√° ocasi√≥n nos interesa saber que est√° pasando tras bambalinas, y precisamente veremos que hace el compilador de *Kotlin* para que esto sea posible.

Usaremos este ejemplo que podemos obtener de la [documentaci√≥n de *Kotlin*](https://kotlinlang.org/docs/reference/basic-syntax.html#using-type-checks-and-automatic-casts):

``` kotlin
fun getStringLength(obj: Any): Int? {
    if (obj is String) {
        // `obj` is automatically cast to `String` in this branch
        return obj.length
    }

    // `obj` is still of type `Any` outside of the type-checked branch
    return null
}
```

Cuando usamos *Kotlin* con la Java Virtual Machine, el compilador convierte el c√≥digo de *Kotlin* a bytecode que la JVM puede luego usar. En este ejemplo no veremos bytecode sino de la ayuda de IntelliJ descompilaremos el bytecode a c√≥digo Java.

Este seria el c√≥digo descompilado a Java del ejemplo anterior:

``` kotlin
public final class AutomaticCasts {
   @Nullable
   public static final Integer getStringLength(@NotNull Object obj) {
      Intrinsics.checkParameterIsNotNull(obj, "obj");
      return obj instanceof String && ((String)obj).length() > 0 ? ((String)obj).length() : null;
   }
}
```

Lo que podemos observar es justamente el c√≥digo que tendr√≠amos que escribir si no existiera una caracter√≠stica como casts autom√°ticos, el cual es el caso de Java. Cada vez que intentamos acceder a un m√©todo de la clase `String` tenemos que hacer cast del objeto a `String` expl√≠citamente. Podemos ver como una caracter√≠stica tan sencilla hace que nuestro c√≥digo sea m√°s conciso y f√°cil de entender.

### ¬øQu√© pasa con otras plataformas?

Pero *Kotlin* no solo corre en la JVM, tambi√©n puede correr en otras plataformas. As√≠ que para finalizar veremos que sucede cuando sea usa *Kotlin* en el frontend con JavaScript. El resultado es casi el mismo ya que JavaScript es un lenguaje d√©bilmente tipado y din√°mico, y no necesita convertir entre tipos de datos.

Aqu√≠ podemos ver el c√≥digo de JavaScript al cual es traducido el ejemplo anterior de *Kotlin*:

``` kotlin
function getStringLength(obj) {
    if (typeof obj === 'string' && obj.length > 0) {
        return obj.length;
    }
    return null;
}
```

Muy parecido no?

### Conclusiones

Vimos m√°s a detalle una caracter√≠stica sencilla que posee *Kotlin* como son los casts autom√°ticos. Pudimos observar que est√° caracter√≠stica en realidad hace que el c√≥digo se vea m√°s conciso y quita mucho ‚Äúoverhead‚Äù que se tendr√≠a que escribir si no se tuviera como es el caso de Java.

Si quieren aprender m√°s de *Kotlin*, pueden vernos en el [canal de Guatemala Kotlin User Group por YouTube](https://www.youtube.com/@GuateKUG) y seguirnos en la cuenta de [Twitter](https://twitter.com/GuateKUG). Todos los viernes tendremos en vivos en donde hablaremos de varios temas que hacen a *Kotlin* un gran lenguaje de programaci√≥n. ü•≥